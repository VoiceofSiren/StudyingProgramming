# ES6

#### 변수 선언 방법
    - let
    - const
<br/>

### 1. let
    - ES5에서 var의 중복 선언을 가능하게 했던 문제점을 극복하고자 나온 선언 방법.
    - 동일한 이름의 변수를 선언할 수 없다.
#### let과 var의 차이점
    - var의 scope는 함수이다.
    - let의 scope는 {}블록이다.
#### [코드 1]
```plaintext
let x = 10;
if (true) {
    let x = 100;
    console.log(x);
}
console.log(x);
```
#### [결과 1]
    100
    10
#### --> [코드 1]에서 10이 할당된 x와 100이 할당된 x가 있다.
#### {} 100이 할당된 x는 블록 안에서만 유효하므로 console에 서로 다른 값이 출력되는 것을 확인할 수 있다.
<br/>

#### 그렇다면 {} 블록 안에서 let x = 100; 이 코드를 쓰기 전에 x가 유효한지를 [코드 2]를 통해 확인해 보고자 한다.
#### [코드 2]
```plaintext
let x = 10;
if (true) {
    console.log(x);
    let x = 100;
    console.log(x);
}
console.log(x);
```
#### [결과 2]
```plaintext
    Uncaught ReferenceError: Cannot access 'x' before initialization
```
#### --> 10을 할당한 x는 {} 블록 내에서 유효하지 않은 것을 확인했다.

<br><br>

### 2. const
    - const로 지정된 변수의 값은 변경할 수 없다.
    - 동일한 이름의 변수를 선언할 수 없다.
#### [코드 3]은 const 변수의 예시를 보여준다.
#### [코드 3]
```plaintext
const c = "1233";
// Error: var c;
// Error: c = "1211";
```
#### 다만, const를 배열 또는 객체로 지정할 경우 배열 또는 객체 자체를 새로 지정할 수는 없지만, 내부 요소의 값을 변경하는 것은 가능하다.
#### [코드 4]와 배열로 지정된 const 변수에 대하여, [코드 5]는 객체로 지정된 const 변수에 대하여 내부 요소의 값을 변경하는 예시를 보여준다.
#### [코드 4]
```plaintext
const arr = ["A", "B", "C"];
console.log(arr);
arr[1] = "D";     // "B"를 "D"로 변경
console.log(arr);
arr.push("E");    // "E"를 마지막 요소로 추가
console.log(arr);
arr.pop();        // 마지막 요소를 제거
console.log(arr);
```
#### [결과 4]
```plaintext
['A', 'B', 'C']
['A', 'D', 'C']
['A', 'D', 'C', 'E']
['A', 'D', 'C']
```
---
#### [코드 5]
```plaintext
const obj = {"key1": "value1",
             "key2": "value2"};
obj["key1"] = "value001";
console.log(obj);
```
#### [결과 5]
```plaintext
{key1: 'value001', key2: 'value2'}
```











